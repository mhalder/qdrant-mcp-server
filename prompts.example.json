{
  "prompts": [
    {
      "name": "setup_rag_collection",
      "description": "Create a new collection optimized for RAG workflows with hybrid search",
      "arguments": [
        {
          "name": "name",
          "description": "Name for the new collection",
          "required": true
        }
      ],
      "template": "Create a new Qdrant collection named '{{name}}' optimized for RAG (Retrieval-Augmented Generation) workflows:\n\n1. Create the collection with hybrid search enabled (enableHybrid: true) to combine semantic and keyword search for better retrieval accuracy\n2. Use Cosine distance metric (optimal for most embedding models)\n3. After creation, show the collection info and explain the configuration\n4. Provide guidance on adding documents with proper metadata structure for RAG use cases"
    },
    {
      "name": "analyze_and_optimize",
      "description": "Analyze a collection and provide optimization recommendations",
      "arguments": [
        {
          "name": "collection",
          "description": "Name of the collection to analyze",
          "required": true
        }
      ],
      "template": "Perform a comprehensive analysis of the '{{collection}}' collection:\n\n1. Get the collection info (dimensions, document count, distance metric, hybrid search status)\n2. Analyze the configuration and provide insights:\n   - Is the distance metric appropriate for the use case?\n   - Should hybrid search be enabled for better results?\n   - Is the document count sufficient for meaningful similarity search?\n3. Provide specific, actionable optimization recommendations\n4. If the collection seems suboptimal, suggest a migration strategy"
    },
    {
      "name": "compare_search_strategies",
      "description": "Compare semantic vs hybrid search to determine best approach",
      "arguments": [
        {
          "name": "collection",
          "description": "Collection name (must have hybrid search enabled)",
          "required": true
        },
        {
          "name": "query",
          "description": "Test query",
          "required": true
        }
      ],
      "template": "Compare search strategies for '{{query}}' in the '{{collection}}' collection:\n\n1. Perform semantic_search and show top 5 results with scores\n2. Perform hybrid_search and show top 5 results with scores\n3. Analyze the differences:\n   - Which results appear in both? Which are unique to each method?\n   - How do the relevance scores compare?\n   - Which method seems more accurate for this query type?\n4. Recommend which search strategy to use based on:\n   - Query characteristics (keyword-heavy vs conceptual)\n   - Result quality and relevance\n   - Use case requirements"
    },
    {
      "name": "migrate_to_hybrid",
      "description": "Migrate an existing collection to use hybrid search",
      "arguments": [
        {
          "name": "source",
          "description": "Name of the existing collection to migrate",
          "required": true
        },
        {
          "name": "target",
          "description": "Name for the new hybrid-enabled collection",
          "required": true
        }
      ],
      "template": "Migrate the '{{source}}' collection to a new hybrid search-enabled collection '{{target}}':\n\n1. First, analyze the source collection to understand its current configuration\n2. Create the target collection with hybrid search enabled, matching the source's distance metric\n3. Guide the user through retrieving documents from the source (note: you'll need to implement a retrieval mechanism or have the user provide the documents)\n4. Explain how to add the documents to the new hybrid collection\n5. Provide verification steps to ensure the migration was successful\n6. Ask if the user wants to delete the old collection after verification"
    },
    {
      "name": "debug_search_quality",
      "description": "Debug poor search results and suggest improvements",
      "arguments": [
        {
          "name": "collection",
          "description": "Collection with poor search quality",
          "required": true
        },
        {
          "name": "problematic_query",
          "description": "A query that returns poor results",
          "required": true
        }
      ],
      "template": "Debug search quality issues in '{{collection}}' for query '{{problematic_query}}':\n\n1. Get collection info to understand the configuration\n2. Perform a search with the problematic query and analyze the results:\n   - Are the scores too low (< 0.5)? This suggests poor embedding quality or mismatched query/document domains\n   - Are irrelevant results ranking highly? This suggests metadata or hybrid search could help\n3. Test if hybrid search is available and compare results\n4. Provide specific recommendations:\n   - Should documents be re-embedded with a different model?\n   - Would metadata filtering help narrow results?\n   - Is the collection too small or missing relevant documents?\n   - Should the distance metric be changed?\n5. Suggest concrete next steps to improve search quality"
    },
    {
      "name": "build_knowledge_base",
      "description": "Guide for building a structured knowledge base with metadata",
      "arguments": [
        {
          "name": "collection",
          "description": "Collection name for the knowledge base",
          "required": true
        },
        {
          "name": "domain",
          "description": "Domain or topic of the knowledge base",
          "required": true
        }
      ],
      "template": "Build a structured knowledge base in '{{collection}}' for the {{domain}} domain:\n\n1. Create (or verify) the collection with hybrid search enabled for optimal retrieval\n2. Design a metadata schema appropriate for {{domain}}, such as:\n   - category/topic fields for filtering\n   - timestamps for temporal filtering\n   - source/author for provenance\n   - confidence/quality scores\n3. Provide guidance on document structure:\n   - Optimal chunk sizes (typically 200-500 tokens)\n   - How to maintain context across chunks\n   - Metadata to include with each document\n4. Show example documents with proper formatting\n5. Explain search strategies for this knowledge base:\n   - When to use metadata filters\n   - When hybrid search adds value\n   - How to handle multi-step queries"
    },
    {
      "name": "index_git_history",
      "description": "Index a repository's git commit history for semantic search",
      "arguments": [
        {
          "name": "repoPath",
          "description": "Path to the git repository to index",
          "required": true
        }
      ],
      "template": "Index the git commit history for the repository at '{{repoPath}}':\n\n1. First, check the current indexing status using get_git_index_status to see if any commits are already indexed\n2. Run index_git_history to index the repository's commit history:\n   - This will extract commit messages, authors, dates, and file changes\n   - Each commit is embedded for semantic search\n3. After indexing completes, show the status summary:\n   - Total commits indexed\n   - Date range covered\n   - Any errors or skipped commits\n4. Demonstrate a sample search to verify the index is working:\n   - Search for 'bug fix' or 'refactor' to show semantic matching\n5. Explain how to keep the index updated:\n   - Use index_new_commits for incremental updates\n   - Consider setting up periodic re-indexing for active repositories"
    },
    {
      "name": "search_project_history",
      "description": "Search git history to understand how a feature or fix was implemented",
      "arguments": [
        {
          "name": "repoPath",
          "description": "Path to the git repository",
          "required": true
        },
        {
          "name": "query",
          "description": "What to search for in the commit history",
          "required": true
        }
      ],
      "template": "Search the git history of '{{repoPath}}' for '{{query}}':\n\n1. First, verify the repository is indexed using get_git_index_status\n   - If not indexed, run index_git_history first\n2. Perform a semantic search using search_git_history:\n   - Search for: '{{query}}'\n   - Return the top 10 most relevant commits\n3. For each relevant commit, analyze:\n   - The commit message and what it indicates about the change\n   - The author and date for context\n   - The files that were modified\n4. Summarize the findings:\n   - How was this feature/fix implemented over time?\n   - Who were the main contributors?\n   - Are there related commits that provide additional context?\n5. Suggest follow-up searches if the initial results need refinement"
    }
  ]
}
